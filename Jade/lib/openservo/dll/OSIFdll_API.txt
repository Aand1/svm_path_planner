/* Open Source InterFace (OSIF) v0.3
  USB to I2C converter. Shared library head information.
    Copyright (C) 2007  Barry Carter <barry.carter@robotfuzz.com>

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

http://www.gnu.org/licenses/gpl.txt

*/
/*
	OSIF (Open Source InterFace) hardware wrapper.
	The OSIF uses libusb for all communications with the hardware. We 
	use USB control messages to send data back and forth to the OSIF. This
	is because we want to keep the USB protocol communication down to a bare
	minimum for certain transactions. The control message controls directly
	which functions in the OSIF are executed.
	A full data read or write uses a standard USB endpoint.
	

	TODO:
		add support for nix /dev/i2c-x kernel driver
		add gpio support


*/

/**
Initialise the OSIF USB interface. Enumerates all connected OSIF devices.

returns: <0 error 1 success
**/
EXPORT int OSIF_init(void)

/**
De-Initialise the OSIF USB interface
**/
EXPORT int OSIF_deinit(void)

/**
Return the OSIF library version for compatibility checks

data: a pointer to a string to be filled with the nice name for
	  the library.

returns: an integer of the version number in  majorminor xxyy
**/
EXPORT int OSIF_get_libversion(unsigned char * data)

/**
Write data to the I2C device.

This will start an I2C transaction (with automatic restart)
and write buflen bytes to address addr

This assumes the device needs a register selection before
doing the write. Some devices don't require this, and
you should either use OSIF_writeonly or put the first byte
to write in the addr register and start writing from +1
offset in data.

adapter: integer of the adapter scanned. 0 indexed.
i2c_addr: integer address of the device.
addr: the register address in the device to read
data: passed in buffer to be filled
buflen: number of bytes to read
issue_stop: issue the stop bit at the end of the transaction?

returns: <0 error 1 success
**/
EXPORT int OSIF_write_data(int adapter, int i2c_addr, unsigned char addr, unsigned char * data, int buflen, int issue_stop )


/** Shortcut to the above function. This will always send a stop at the end of the write **/
EXPORT int OSIF_write(int adapter, int i2c_addr, unsigned char addr, unsigned char * data, int buflen )
	
/**
Write data to the I2C device.
This will start an I2C transaction (with automatic restart)
and write buflen bytes to address addr

This assumes the device does NOT need a register selection before
doing the write. Some devices do require this, and
you should either use OSIF_write or put the register selection
byte at element 0 in your data string

adapter: integer of the adapter scanned. 0 indexed.
i2c_addr: integer address of the device.
addr: the register address in the device to read
data: passed in buffer to be filled
buflen: number of bytes to read. Current hardware limit is 64 bytes
issue_stop: do we want to send the I2C stop signal after the
			transaction? issue_stop will switch off the request

returns: <0 error 1 success
**/
EXPORT int OSIF_writeonly(int adapter, int i2c_addr, unsigned char * data, int buflen, int issue_stop )

/**
Read from the I2C device at address addr
will fill data into the read buffer.

Note:
This function will do a write before a read
with a restart.

adapter: integer of the adapter scanned. 0 indexed.
i2c_addr: integer address of the device.
addr: the register address in the device to read
data: passed in buffer to be filled
buflen: number of bytes to read. read in small chunks. 64 bytes is a realistic figure
issue_stop: issue the stop bit at the end of the transaction?

returns: <0 error 1 success
**/
EXPORT int OSIF_read_data(int adapter, int i2c_addr, unsigned char addr, unsigned char * data, int buflen, int issue_stop )

/** Shortcut to the above function with an I2C stop bit **/
EXPORT int OSIF_read(int adapter, int i2c_addr, unsigned char addr, unsigned char * data, int buflen)

/**
Read from the I2C device at address addr
will fill data into the read buffer.

Note:
This function will NOT do a write before a read
it will only perform a read. Make sure the I2C
device is setup for this read only transfer
by using OSIF_write, or alternatively be
sure your device supports this method of communication

adapter: integer of the adapter scanned. 0 indexed.
i2c_addr: integer address of the device.
data: passed in buffer to be filled
issue_stop: issue the stop bit at the end of the transaction?

returns: <0 error 1 success
 **/
EXPORT int OSIF_readonly(int adapter, int i2c_addr, unsigned char * data, int buflen, int issue_stop )

/**
Scan the I2C bus for devices.

Scan the I2C bus by addressing all devices (0x01 to 0x7F) in turn and waiting
to see if we get an ACK
Note not all devices work like this, and can send some devices into an unknown
state. BE CAREFUL.

adapter: integer of the adapter scanned. 0 indexed.
devices: *devices with 1d array of devices on bus and *dev_count with number found
dev_count: returns the number of devices found on the bus

returns: <0 error 1 success
**/
EXPORT int OSIF_scan(int adapter, int devices[], int *dev_count )

/**
Probe a device at a given address to see if it will ACK

adapter: integer of the adapter scanned. 0 indexed.
i2c_addr: integer address of the device.

returns: true if a device is found at address
**/
EXPORT bool OSIF_probe(int adapter, int i2c_addr )

/**
Write 1 to a register in the device in one transaction.
generally used for "command" functions in I2C slave
devices that will trigger a function from a write to
a register.

adapter: integer of the adapter scanned. 0 indexed.
i2c_addr: integer address of the device.
command: the register to write to.

returns: <0 error 1 success
**/
EXPORT int OSIF_command(int adapter, int i2c_addr, unsigned char command)

/**
Get a count of the connected OSIF adapters:

returns: number of connected OSIF adapters
**/
EXPORT int OSIF_get_adapter_count(void)

/**
Query the connected OSIF for its name.
May also be used for firmware version.

adapter: integer of the adapter scanned. 0 indexed.
name: character string filled with the name

returns: always 1
**/
EXPORT int OSIF_get_adapter_name(int adapter, char* name)

/**
GPIO Control function to set the direction of the pins, and is enabled
    If you set the I2C pins (SDA SCL) as outputs, you will disable the
    i2c module. Be warned!
adapter: integer of the adapter scanned. 0 indexed.
ddr: a bitwise OR of the pins to set as input(0) or output(1)
    eg gpio1(TX) and gpio2(RX)  00000011 or 0x03
enabled: a bitwise OR to enable the pin (1) for future writes. Can be used as a mask
**/
/**
 // TX line
 // RX line
 // MISO
 // MOSI
 // SDA
 // SCL
**/
EXPORT int OSIF_io_set_ddr(int adapter_no, int ddr, int enabled)

/**
GPIO Control function to set pin high or low
    (only works if ddr set to output)

adapter: integer of the adapter scanned. 0 indexed.
io: a bitwise OR of the pins to set high (1) or low (0)
    eg gpio1(TX) and gpio2(RX)  00000011 or 0x03 to set those high
**/
EXPORT int OSIF_io_set_out(int adapter_no, int io)

/**
GPIO Control function to read the status of all gpio pins

adapter: integer of the adapter scanned. 0 indexed.
io: a single bitwise OR int representing all bits of the gpio pins
    eg gpio1(TX) and gpio2(RX) are high, returns 00000011 or 0x03
enabled: a bitwise OR to enable the pin (1) for future writes. Can be used as a mask
**/
EXPORT int OSIF_io_get_in(int adapter_no)

/**
Shortcut functions to update one pin only
**/
EXPORT int OSIF_io_set_out1(int adapter_no, int gpio, int state)

/**
get the current pin states. THIS IS NOT suitable for asking the osif what pins
are set when this lib loaded, OSIF doesn't know that. It is this lib that keeps
tabs on what pins are being set/uset
**/
EXPORT int OSIF_io_get_current(int adapter_no)

/**
Disable the I2C port in case we want to use the pins as gpios,
or if we want to reset the I2C module
**/
EXPORT int OSIF_disable_i2c(int adapter_no)

/**
Enable a previously disabled I2C module
**/
EXPORT int OSIF_enable_i2c(int adapter_no)

EXPORT int OSIF_set_bitrate(int adapter_no, int bitrate_hz)

EXPORT int OSIF_set_twbr(int adapter_no, int twbr, int twps)

